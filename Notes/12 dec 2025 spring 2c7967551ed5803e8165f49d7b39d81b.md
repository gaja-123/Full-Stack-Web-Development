# 12 dec 2025 spring

Date: December 12, 2025

## Key Takeways

1. 

## Action

---

- [ ]  

## Notes

---

# Why java framworks?

1. too complex, heavy weight
2. framework → predefined code + specifc problem slove
3. efficiency,security,expese,support ( java framework adv.)
4. resriction,code public,custome built feature ( disadv.)
5. spring,maven,hibernate,etc

# Spring framework

1. Helps in delivery in time.
2. is framework of framework.
3. interface → write the impletation in own way of us.
4. ecosystem ⇒ web layer, common layer,service layer,data layer.
5. why ? industrial (40%)
    1. distinct division b/e bean of MVC.
    2. intefaces use -. we can write imlemataion.
    3. easy to test.(Junit)
    4. spring controller by IoC
    5. better to integrate with new tech.
    6. apllication framework,light weight,layered architecture,loose coupling, integrate with ORM tech.

# Spring archtecture

1. test
2. core
3. AOP
4. data access / integration
5. web

# Spring module

1. core four things-
    1. core
    2. bean
    3. context
    4. spring expression lang.

# spring first program

1. bean class → xml class →demo class →load jar file →  run

1. class → then object  ( traditional)
2. spring | IoC → no object creation by us ( instead config. in xml file by developer) this by spring container by parsing XML file. why? XML file not part of source code.
3. bean/model/PoJO ( no business logic in class. only attri,setter,getter,etc)
4. traditional ( object construction by developer)
5. spring way ( use Ioc) → use XML file ⇒ beans and bean, and property. ⇒ then use API/infterface i.e. classpathresource, bean factory( parse xml file and construct object). [ object creatd by spring core container]
6. spring create object only if bean creation requested.
7. Application context ( 2nd spring container) is implemtation of beanfactory( 1st spring container way) ⇒ application context create object even if not bean requested.

# IoC container

1. Feature:
    1. create object
    2. mainge object lifecycle
    3. config.( key value pair in xml)
    4. wiring \
2. input : metadata(xml,type) + PoJo CLass → output :ready to run application ( by spring container)
3. bean factory and application context ( 2 types)

# Bean

1. object managed by spring container
2. life cycle by spring container
3. config. metadata to spring container → bean object.

Life cycle:

1.instantiate →populate properties ( by setter) →…..→destory bean after shutdown of container.

1. init method ( after constutor)
2. destory method ( after application context close)

# Dependency injection

1. coupling → high and low
2. reduce coupling
3. by xml file 
4. 2 ways → setter and constructor ways.
5. dependency → class A uses functionality of class B ( class A has depedncy of class B)
6. dependency injection → the proces of creating an object for some other class and let the class directly using the dependency
7. injector class creates an object of service class and then injects the object to the client object.
8. Inversion of Control  principle⇒ gives depdnency injection ( focus on flow of app , not object creation)
9. types of DI →1) construtor 2)setter 3)interface
10. advantages → change objects at run time ( no class recreation for changes),losse coupling,unit testing easier,reduce bolierplate code.
11. [springapplication.run](http://springapplication.run) ⇒ gives spring container that contains beans.
12.